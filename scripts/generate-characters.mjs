import fs from "node:fs";
import path from "node:path";

const projectRoot = process.cwd();

// âœ… AJUSTA SI TU CSV ESTÃ EN data/ o con otro nombre
// Ejemplos:
// const CSV_PATH = path.join(projectRoot, "data", "otakle_characters.csv");
const CSV_PATH = path.join(projectRoot, "otakle_characters.csv");

const OUT_PATH = path.join(projectRoot, "src", "characters.ts");

function norm(s) {
  return String(s ?? "").trim().toLowerCase();
}

function cleanText(v) {
  return String(v ?? "").trim();
}

function toBool(v, fallback = true) {
  const s = norm(v);
  if (s === "") return fallback;
  if (["true", "1", "yes", "y", "si", "sÃ­"].includes(s)) return true;
  if (["false", "0", "no", "n"].includes(s)) return false;
  return fallback;
}

function toNumberOrNull(v) {
  const s = cleanText(v);
  if (!s || s === "?") return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

// CSV simple (si tienes comillas con comas dentro, dime y te hago parser robusto)
function parseCSV(text) {
  const lines = text.split(/\r?\n/).filter((l) => l.trim().length > 0);
  const header = lines[0].split(",").map((h) => h.trim());
  return lines.slice(1).map((line) => {
    const cols = line.split(",").map((c) => c.trim());
    const obj = {};
    header.forEach((h, i) => (obj[h] = cols[i] ?? ""));
    return obj;
  });
}

function canonicalAnime(input) {
  const s = norm(input);

  if (
    s.includes("boku no hero") ||
    s.includes("my hero academia") ||
    s === "bnha" ||
    s === "mha"
  ) {
    return "My Hero Academia";
  }

  return cleanText(input);
}

// âœ… Normaliza categorÃ­as de edad
function canonicalAgeGroup(v) {
  const raw = cleanText(v);
  const s = norm(raw);

  if (!s || s === "?" || s === "unknown" || s === "desconocido") return "Desconocido";
  if (s === "nino" || s === "niÃ±o") return "NiÃ±o";
  if (s === "adolescente") return "Adolescente";
  if (s === "adulto") return "Adulto";

  // si pusiste otras etiquetas en el CSV, las respetamos
  return raw;
}

// Para template strings TS
function escTemplate(s) {
  return String(s ?? "")
    .replace(/\\/g, "\\\\")
    .replace(/`/g, "\\`")
    .replace(/\$\{/g, "\\${");
}

if (!fs.existsSync(CSV_PATH)) {
  console.error(`âŒ No encontrÃ© el CSV en: ${CSV_PATH}`);
  console.error(`ðŸ‘‰ SoluciÃ³n: mueve el CSV ahÃ­ o cambia CSV_PATH en generate-characters.mjs`);
  process.exit(1);
}

const csvText = fs.readFileSync(CSV_PATH, "utf8");
const rows = parseCSV(csvText);

// Genera characters
const characters = rows
  .map((r) => {
    const id = cleanText(r.id);
    if (!id) return null;

    const imageFileName = cleanText(r.imageFileName);
    const imageUrl = imageFileName ? `/images/${imageFileName}` : "/images/placeholder.png";

    const yearDebut = toNumberOrNull(r.yearDebut ?? r.debutYear); // soporta ambos nombres
    const debutYearCompat = yearDebut ?? 0; // compatibilidad

    const ageDebutGroup = canonicalAgeGroup(r.ageDebutGroup ?? r.ageDebut);
    const ageMainGroup = canonicalAgeGroup(r.ageMainGroup ?? r.ageMain);

    return {
      id,
      name: cleanText(r.name),
      anime: canonicalAnime(r.anime),
      genre: cleanText(r.genre),
      yearDebut,                 // âœ… lo que usa la UI nueva
      debutYear: debutYearCompat, // âœ… compat, no molesta
      studio: cleanText(r.studio),
      role: cleanText(r.role),
      gender: cleanText(r.gender),
      race: cleanText(r.race),
      debutInfo: cleanText(r.debutInfo),
      active: toBool(r.active, true),

      // âœ… lo que usa la UI para mostrar NiÃ±o/Adolescente/Adulto
      ageDebutGroup,
      ageMainGroup,

      imageUrl,
    };
  })
  .filter(Boolean);

// Orden estable (opcional)
characters.sort((a, b) => {
  const aa = (a.anime || "").localeCompare(b.anime || "");
  if (aa !== 0) return aa;
  return (a.name || "").localeCompare(b.name || "");
});

const file = `/* eslint-disable */
// AUTO-GENERATED FILE. DO NOT EDIT DIRECTLY.
// Generated by scripts/generate-characters.mjs

export type Character = {
  id: string
  name: string
  anime: string
  genre: string
  yearDebut: number | null
  debutYear: number
  studio: string
  role: string
  gender: string
  race: string
  debutInfo: string
  active?: boolean
  ageDebutGroup?: string
  ageMainGroup?: string
  imageUrl: string
}

export const CHARACTERS: Character[] = [
${characters
  .map(
    (c) => `  {
    id: \`${escTemplate(c.id)}\`,
    name: \`${escTemplate(c.name)}\`,
    anime: \`${escTemplate(c.anime)}\`,
    genre: \`${escTemplate(c.genre)}\`,
    yearDebut: ${c.yearDebut == null ? "null" : c.yearDebut},
    debutYear: ${Number.isFinite(c.debutYear) ? c.debutYear : 0},
    studio: \`${escTemplate(c.studio)}\`,
    role: \`${escTemplate(c.role)}\`,
    gender: \`${escTemplate(c.gender)}\`,
    race: \`${escTemplate(c.race)}\`,
    debutInfo: \`${escTemplate(c.debutInfo)}\`,
    active: ${c.active === false ? "false" : "true"},
    ageDebutGroup: \`${escTemplate(c.ageDebutGroup ?? "Desconocido")}\`,
    ageMainGroup: \`${escTemplate(c.ageMainGroup ?? "Desconocido")}\`,
    imageUrl: \`${escTemplate(c.imageUrl)}\`,
  },`
  )
  .join("\n")}
]
`;

fs.writeFileSync(OUT_PATH, file, "utf8");
console.log(`âœ… characters.ts generado (${characters.length} personajes) -> ${OUT_PATH}`);
